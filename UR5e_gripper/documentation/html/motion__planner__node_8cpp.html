<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Commands: robot_commands/src/motion_planner_node.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Commands
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">UR5e planning modules</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7d15bc708aa0cd7d821b916368004b3b.html">robot_commands</a></li><li class="navelem"><a class="el" href="dir_398bc453f25c68602f1d94e332958cc6.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">motion_planner_node.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ROS Node che esegue il movimento completo del braccio completo leggendo i valori dai messaggi dei topic specifici.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;moveit/move_group_interface/move_group_interface.h&gt;</code><br />
<code>#include &lt;moveit/planning_scene_interface/planning_scene_interface.h&gt;</code><br />
<code>#include &lt;moveit/planning_scene_monitor/planning_scene_monitor.h&gt;</code><br />
<code>#include &lt;tf2_geometry_msgs/tf2_geometry_msgs.h&gt;</code><br />
<code>#include &lt;tf2/LinearMath/Quaternion.h&gt;</code><br />
<code>#include &lt;moveit_msgs/OrientationConstraint.h&gt;</code><br />
<code>#include &lt;moveit_msgs/JointConstraint.h&gt;</code><br />
<code>#include &lt;moveit_msgs/AttachedCollisionObject.h&gt;</code><br />
<code>#include &lt;gazebo_msgs/SpawnModel.h&gt;</code><br />
<code>#include &lt;gazebo_ros_link_attacher/Attach.h&gt;</code><br />
<code>#include &lt;gazebo_ros_link_attacher/AttachRequest.h&gt;</code><br />
<code>#include &lt;gazebo_ros_link_attacher/AttachResponse.h&gt;</code><br />
<code>#include &lt;moveit/trajectory_processing/time_optimal_trajectory_generation.h&gt;</code><br />
<code>#include &lt;moveit/robot_trajectory/robot_trajectory.h&gt;</code><br />
<code>#include &lt;std_msgs/String.h&gt;</code><br />
<code>#include &lt;std_srvs/Trigger.h&gt;</code><br />
<code>#include &lt;pcl_action/custom.h&gt;</code><br />
<code>#include &lt;ros/ros.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for motion_planner_node.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="motion__planner__node_8cpp__incl.png" border="0" usemap="#robot__commands_2src_2motion__planner__node_8cpp" alt=""/></div>
<map name="robot__commands_2src_2motion__planner__node_8cpp" id="robot__commands_2src_2motion__planner__node_8cpp">
<area shape="rect" title="ROS Node che esegue il movimento completo del braccio completo leggendo i valori dai messaggi dei top..." alt="" coords="2030,5,2205,47"/>
<area shape="rect" title=" " alt="" coords="5,102,197,143"/>
<area shape="rect" title=" " alt="" coords="222,95,397,151"/>
<area shape="rect" title=" " alt="" coords="421,95,587,151"/>
<area shape="rect" title=" " alt="" coords="612,102,769,143"/>
<area shape="rect" title=" " alt="" coords="794,109,977,136"/>
<area shape="rect" title=" " alt="" coords="1001,109,1237,136"/>
<area shape="rect" title=" " alt="" coords="1261,109,1462,136"/>
<area shape="rect" title=" " alt="" coords="1487,102,1692,143"/>
<area shape="rect" title=" " alt="" coords="1717,109,1910,136"/>
<area shape="rect" title=" " alt="" coords="1935,102,2105,143"/>
<area shape="rect" title=" " alt="" coords="2129,102,2300,143"/>
<area shape="rect" title=" " alt="" coords="2324,102,2495,143"/>
<area shape="rect" title=" " alt="" coords="2519,95,2708,151"/>
<area shape="rect" title=" " alt="" coords="2732,102,2887,143"/>
<area shape="rect" title=" " alt="" coords="2911,109,3039,136"/>
<area shape="rect" title=" " alt="" coords="3063,109,3190,136"/>
<area shape="rect" title=" " alt="" coords="3215,109,3353,136"/>
<area shape="rect" title=" " alt="" coords="3378,109,3451,136"/>
<area shape="rect" title=" " alt="" coords="3476,109,3543,136"/>
<area shape="rect" title=" " alt="" coords="3567,109,3633,136"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afd29c78cd36d8946cf1202e8e684f7a5"><td class="memItemLeft" align="right" valign="top"><a id="afd29c78cd36d8946cf1202e8e684f7a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIMULATION</b>&#160;&#160;&#160;false</td></tr>
<tr class="separator:afd29c78cd36d8946cf1202e8e684f7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c36b4b60469cd7ed9a16478d676f56"><td class="memItemLeft" align="right" valign="top"><a id="ad7c36b4b60469cd7ed9a16478d676f56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_VELOCITY_SCALING_FACTOR</b>&#160;&#160;&#160;0.55</td></tr>
<tr class="separator:ad7c36b4b60469cd7ed9a16478d676f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd603c23177e9248affed872d662c44"><td class="memItemLeft" align="right" valign="top"><a id="a9bd603c23177e9248affed872d662c44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_ACCELLERATION_SCALING_FACTOR</b>&#160;&#160;&#160;0.55</td></tr>
<tr class="separator:a9bd603c23177e9248affed872d662c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba9953c91bbb369d6cd128e3fba71df"><td class="memItemLeft" align="right" valign="top"><a id="a7ba9953c91bbb369d6cd128e3fba71df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CARTESIAN_MAX_VELOCITY_SCALING_FACTOR</b>&#160;&#160;&#160;0.05</td></tr>
<tr class="separator:a7ba9953c91bbb369d6cd128e3fba71df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5680b0ce3aa71f847e305ae06a440e1"><td class="memItemLeft" align="right" valign="top"><a id="af5680b0ce3aa71f847e305ae06a440e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CARTESIAN_MAX_ACCELLERATION_SCALING_FACTOR</b>&#160;&#160;&#160;0.05</td></tr>
<tr class="separator:af5680b0ce3aa71f847e305ae06a440e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f8018a3653140d4dffb9c0fb4fcb6c"><td class="memItemLeft" align="right" valign="top"><a id="a87f8018a3653140d4dffb9c0fb4fcb6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Z_BASE_LINK</b>&#160;&#160;&#160;1.791</td></tr>
<tr class="separator:a87f8018a3653140d4dffb9c0fb4fcb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac4ae7eb81ec609c87d411c39e435dd"><td class="memItemLeft" align="right" valign="top"><a id="a2ac4ae7eb81ec609c87d411c39e435dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Z_DESK</b>&#160;&#160;&#160;0.8675</td></tr>
<tr class="separator:a2ac4ae7eb81ec609c87d411c39e435dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a93152646fa4880ebb582309c88295"><td class="memItemLeft" align="right" valign="top"><a id="aa8a93152646fa4880ebb582309c88295"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Z_MIN</b>&#160;&#160;&#160;1.035</td></tr>
<tr class="separator:aa8a93152646fa4880ebb582309c88295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec98a3999413a46267eafa17015d2b8"><td class="memItemLeft" align="right" valign="top"><a id="aeec98a3999413a46267eafa17015d2b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Z_INCREMENT</b>&#160;&#160;&#160;0.05</td></tr>
<tr class="separator:aeec98a3999413a46267eafa17015d2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be3fccf9291c6e12c1c158097410a2"><td class="memItemLeft" align="right" valign="top"><a id="a38be3fccf9291c6e12c1c158097410a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_CUBE_ROWS</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a38be3fccf9291c6e12c1c158097410a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dccfb12e57169d4b30e7185e6dbedb5"><td class="memItemLeft" align="right" valign="top"><a id="a5dccfb12e57169d4b30e7185e6dbedb5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PARA_ROWS</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a5dccfb12e57169d4b30e7185e6dbedb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8fcc83dd8e235b09f62ea6e505750c"><td class="memItemLeft" align="right" valign="top"><a id="a2a8fcc83dd8e235b09f62ea6e505750c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_CUBE_PER_ROW</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a2a8fcc83dd8e235b09f62ea6e505750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2288e4c6825be30aa4166e22d9d1f167"><td class="memItemLeft" align="right" valign="top"><a id="a2288e4c6825be30aa4166e22d9d1f167"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PARA_PER_ROW</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a2288e4c6825be30aa4166e22d9d1f167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75783a188e5f11550cd57b19ef43730d"><td class="memItemLeft" align="right" valign="top"><a id="a75783a188e5f11550cd57b19ef43730d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_CUBE_SPACE</b>&#160;&#160;&#160;0.045</td></tr>
<tr class="separator:a75783a188e5f11550cd57b19ef43730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7df2009a00a0120cf64b67319193db"><td class="memItemLeft" align="right" valign="top"><a id="aaf7df2009a00a0120cf64b67319193db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PARA_SPACE</b>&#160;&#160;&#160;0.07</td></tr>
<tr class="separator:aaf7df2009a00a0120cf64b67319193db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298f4bbb7c64b0ba5ac02c4008fcefa0"><td class="memItemLeft" align="right" valign="top"><a id="a298f4bbb7c64b0ba5ac02c4008fcefa0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_ROW_SPACE</b>&#160;&#160;&#160;0.08</td></tr>
<tr class="separator:a298f4bbb7c64b0ba5ac02c4008fcefa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75bb2c9473dbb8bd29dcd0ed26e610f"><td class="memItemLeft" align="right" valign="top"><a id="af75bb2c9473dbb8bd29dcd0ed26e610f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CUBE_MEASURE</b>&#160;&#160;&#160;0.025</td></tr>
<tr class="separator:af75bb2c9473dbb8bd29dcd0ed26e610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfc030d65d23898b85a9b8c45c128e2"><td class="memItemLeft" align="right" valign="top"><a id="acbfc030d65d23898b85a9b8c45c128e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PARALLELEPIPED_MEASURE</b>&#160;&#160;&#160;0.05</td></tr>
<tr class="separator:acbfc030d65d23898b85a9b8c45c128e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4fc01d736fe50cf5b977f755b675f11d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a> ()</td></tr>
<tr class="memdesc:a4fc01d736fe50cf5b977f755b675f11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzone che inizializza le variabili globali e i puntatori.  <a href="motion__planner__node_8cpp.html#a4fc01d736fe50cf5b977f755b675f11d">More...</a><br /></td></tr>
<tr class="separator:a4fc01d736fe50cf5b977f755b675f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c40266d9f81945e7305b9f706067772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a0c40266d9f81945e7305b9f706067772">robot_constraints</a> ()</td></tr>
<tr class="memdesc:a0c40266d9f81945e7305b9f706067772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che inizializza le costrizioni dei vari valori dei joint e orientazione dell'end-effector del braccio, valori testati in modo da limitare il braccio all'area di lavoro per favorire soluzioni 'ottimali' dell'inverse kinematics.  <a href="motion__planner__node_8cpp.html#a0c40266d9f81945e7305b9f706067772">More...</a><br /></td></tr>
<tr class="separator:a0c40266d9f81945e7305b9f706067772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab62f81b3f3a3625b4f73c19ceeff62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a4ab62f81b3f3a3625b4f73c19ceeff62">add_cube</a> (geometry_msgs::Pose pose, int index)</td></tr>
<tr class="memdesc:a4ab62f81b3f3a3625b4f73c19ceeff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che aggiunge il cubo specificato a Gazebo.  <a href="motion__planner__node_8cpp.html#a4ab62f81b3f3a3625b4f73c19ceeff62">More...</a><br /></td></tr>
<tr class="separator:a4ab62f81b3f3a3625b4f73c19ceeff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4cdd7ecb35c7c3a09042860e634b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a9a4cdd7ecb35c7c3a09042860e634b71">add_parallelepiped</a> (geometry_msgs::Pose pose, int index)</td></tr>
<tr class="memdesc:a9a4cdd7ecb35c7c3a09042860e634b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che aggiunge il parallelepipedo specificato a Gazebo.  <a href="motion__planner__node_8cpp.html#a9a4cdd7ecb35c7c3a09042860e634b71">More...</a><br /></td></tr>
<tr class="separator:a9a4cdd7ecb35c7c3a09042860e634b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e2f3befdda031eac3f973b147f6567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a19e2f3befdda031eac3f973b147f6567">add_cube_collision</a> (geometry_msgs::Pose pose, int index)</td></tr>
<tr class="memdesc:a19e2f3befdda031eac3f973b147f6567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che aggiunge l'oggetto di collisione 'cube_collision_ <em>index</em> ' alla scena MoveIt!  <a href="motion__planner__node_8cpp.html#a19e2f3befdda031eac3f973b147f6567">More...</a><br /></td></tr>
<tr class="separator:a19e2f3befdda031eac3f973b147f6567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c8604f264a12ae8c9eddafa32234f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#aa1c8604f264a12ae8c9eddafa32234f0">add_parallelepiped_collision</a> (geometry_msgs::Pose pose, int index)</td></tr>
<tr class="memdesc:aa1c8604f264a12ae8c9eddafa32234f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che aggiunge l'oggetto di collisione 'parallelepiped_collision_ <em>index</em> ' alla scena MoveIt!  <a href="motion__planner__node_8cpp.html#aa1c8604f264a12ae8c9eddafa32234f0">More...</a><br /></td></tr>
<tr class="separator:aa1c8604f264a12ae8c9eddafa32234f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b2ee5dbf47d7ba57716e68e1c3eb28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#ab3b2ee5dbf47d7ba57716e68e1c3eb28">removeCollision</a> (int sig)</td></tr>
<tr class="memdesc:ab3b2ee5dbf47d7ba57716e68e1c3eb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che rimuove le collisioni dalla scena MoveIt!  <a href="motion__planner__node_8cpp.html#ab3b2ee5dbf47d7ba57716e68e1c3eb28">More...</a><br /></td></tr>
<tr class="separator:ab3b2ee5dbf47d7ba57716e68e1c3eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c918a2f229ff3dd525a627351c35b4"><td class="memItemLeft" align="right" valign="top">geometry_msgs::Pose&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a77c918a2f229ff3dd525a627351c35b4">get_buffer_target</a> (int counter)</td></tr>
<tr class="memdesc:a77c918a2f229ff3dd525a627351c35b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che calcola la posa dell'end-effector per posizionare il blocco nel buffer tramite l'indice 'counter'. La funzione calcola la posa in base alle costanti presenti e alle pose di default.  <a href="motion__planner__node_8cpp.html#a77c918a2f229ff3dd525a627351c35b4">More...</a><br /></td></tr>
<tr class="separator:a77c918a2f229ff3dd525a627351c35b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b92b4fd213b7801012434961330419"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#ad8b92b4fd213b7801012434961330419">get_index_from_buffer_pose</a> (geometry_msgs::Pose target)</td></tr>
<tr class="memdesc:ad8b92b4fd213b7801012434961330419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che trova l'indice tra le collisioni del blocco con la posa specificata e lo ritorna.  <a href="motion__planner__node_8cpp.html#ad8b92b4fd213b7801012434961330419">More...</a><br /></td></tr>
<tr class="separator:ad8b92b4fd213b7801012434961330419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa2b60e07dd3330105db81b4db9b2b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#acaa2b60e07dd3330105db81b4db9b2b3">open_gripper</a> (ros::Publisher pub, std::string model)</td></tr>
<tr class="memdesc:acaa2b60e07dd3330105db81b4db9b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue l'apertura del gripper in ambiente reale e simulato.  <a href="motion__planner__node_8cpp.html#acaa2b60e07dd3330105db81b4db9b2b3">More...</a><br /></td></tr>
<tr class="separator:acaa2b60e07dd3330105db81b4db9b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3536311b9a73eafe4618611c0362d9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a3536311b9a73eafe4618611c0362d9a7">close_gripper</a> (ros::Publisher pub, std::string model)</td></tr>
<tr class="memdesc:a3536311b9a73eafe4618611c0362d9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue la chiusura del gripper in ambiente reale e simulato.  <a href="motion__planner__node_8cpp.html#a3536311b9a73eafe4618611c0362d9a7">More...</a><br /></td></tr>
<tr class="separator:a3536311b9a73eafe4618611c0362d9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4f7edb241686aacb8145a9ba417e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a2f4f7edb241686aacb8145a9ba417e2d">motion_plan</a> (geometry_msgs::Pose target)</td></tr>
<tr class="memdesc:a2f4f7edb241686aacb8145a9ba417e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue il planning ed il movimento del braccio verso una posa dell'end-effector passata come parametro.  <a href="motion__planner__node_8cpp.html#a2f4f7edb241686aacb8145a9ba417e2d">More...</a><br /></td></tr>
<tr class="separator:a2f4f7edb241686aacb8145a9ba417e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad6bf04107d106688d681b97a334801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#aaad6bf04107d106688d681b97a334801">motion_plan_middle</a> (geometry_msgs::Pose target)</td></tr>
<tr class="memdesc:aaad6bf04107d106688d681b97a334801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue il planning ed il movimento del braccio verso una posa dell'end-effector data come parametro, passando per un punto intermedio definito a priori come posa (nel file .srdf di MoveIt!). Il movimento è l'unione di due traiettorie pianificate separatamente e con il timing ricalcolato.  <a href="motion__planner__node_8cpp.html#aaad6bf04107d106688d681b97a334801">More...</a><br /></td></tr>
<tr class="separator:aaad6bf04107d106688d681b97a334801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e12409508f78abe16f1741c18637fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#ab3e12409508f78abe16f1741c18637fc">execute_Cartesian_Path</a> (geometry_msgs::Pose target)</td></tr>
<tr class="memdesc:ab3e12409508f78abe16f1741c18637fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue il planning ed il movimento del braccio linearmente verso una posa dell'end-effector passata come parametro.  <a href="motion__planner__node_8cpp.html#ab3e12409508f78abe16f1741c18637fc">More...</a><br /></td></tr>
<tr class="separator:ab3e12409508f78abe16f1741c18637fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c18e17b9d822531a159010049d175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a7d6c18e17b9d822531a159010049d175">select_arm_motion_plan</a> (geometry_msgs::Pose target)</td></tr>
<tr class="memdesc:a7d6c18e17b9d822531a159010049d175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che sceglie se far passare il braccio per il punto medio oppure no. Il passaggio avviene supponendo di divirere il tavolo di lavoro in due metà rispetto all'origine del robot: se origine e destinazione si trovano sulla stessa metà allora non serve passare per il waypoint.  <a href="motion__planner__node_8cpp.html#a7d6c18e17b9d822531a159010049d175">More...</a><br /></td></tr>
<tr class="separator:a7d6c18e17b9d822531a159010049d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792e44f027d5c332de077c7d367714ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a792e44f027d5c332de077c7d367714ef">rotate_end_effector</a> (int joint_number, double amount)</td></tr>
<tr class="memdesc:a792e44f027d5c332de077c7d367714ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che assegna ad un determinato joint un valore passato come parametro (consultare il file URDF del robot per maggiori informazioni, numerazione crescente)  <a href="motion__planner__node_8cpp.html#a792e44f027d5c332de077c7d367714ef">More...</a><br /></td></tr>
<tr class="separator:a792e44f027d5c332de077c7d367714ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af608bba0b50bde82e9edd251fda75662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#af608bba0b50bde82e9edd251fda75662">pickup</a> (ros::Publisher gripper_pub)</td></tr>
<tr class="memdesc:af608bba0b50bde82e9edd251fda75662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue il movimento in sequenza del braccio, chiamando le apposite funzioni, per la presa dei blocchi (con collisioni)  <a href="motion__planner__node_8cpp.html#af608bba0b50bde82e9edd251fda75662">More...</a><br /></td></tr>
<tr class="separator:af608bba0b50bde82e9edd251fda75662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb468c8404de768b7718baf3afffe7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a3fb468c8404de768b7718baf3afffe7c">place</a> (ros::Publisher gripper_pub)</td></tr>
<tr class="memdesc:a3fb468c8404de768b7718baf3afffe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue il movimento in sequenza del braccio, chiamando le apposite funzioni, per il posizionamento dei blocchi (con collisioni)  <a href="motion__planner__node_8cpp.html#a3fb468c8404de768b7718baf3afffe7c">More...</a><br /></td></tr>
<tr class="separator:a3fb468c8404de768b7718baf3afffe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che esegue il movimento in sequenza del braccio, chiamando le apposite funzioni, per il posizionamento di default del manipolatore.  <a href="motion__planner__node_8cpp.html#ad20897c5c8bd47f5d4005989bead0e55">More...</a><br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f686a6191d7d83185c21872036fb79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a25f686a6191d7d83185c21872036fb79">confirmation_msgs</a> (ros::Publisher confirmation_pub)</td></tr>
<tr class="memdesc:a25f686a6191d7d83185c21872036fb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che invia il messaggio di conferma del movimento al nodo del planning.  <a href="motion__planner__node_8cpp.html#a25f686a6191d7d83185c21872036fb79">More...</a><br /></td></tr>
<tr class="separator:a25f686a6191d7d83185c21872036fb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859cd1bdea5bd730a7534e3a5c8cdbbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a859cd1bdea5bd730a7534e3a5c8cdbbc">buffer_callback</a> (const pcl_action::custom::ConstPtr &amp;msg)</td></tr>
<tr class="memdesc:a859cd1bdea5bd730a7534e3a5c8cdbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione callback chiamata dopo la ricezione del messaggio dal nodo della camera, inizializza la posa iniziale e il tipo di blocco in base ai valori del messaggio. In aggiunta setta la variabile flag 'position_flag' per segnalare al loop principale di eseguire il movimento.  <a href="motion__planner__node_8cpp.html#a859cd1bdea5bd730a7534e3a5c8cdbbc">More...</a><br /></td></tr>
<tr class="separator:a859cd1bdea5bd730a7534e3a5c8cdbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72a0dd5b254704625684cba98acbfd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#ad72a0dd5b254704625684cba98acbfd5">pickup_callback</a> (const geometry_msgs::PoseStampedPtr &amp;msg)</td></tr>
<tr class="memdesc:ad72a0dd5b254704625684cba98acbfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione callback chiamata dopo la ricezione del messaggio dal nodo del planning, inizializza la posa finale in base ai valori del messaggio. In aggiunta setta la variabile flag 'pickup_flag' per segnalare al loop principale di eseguire il movimento.  <a href="motion__planner__node_8cpp.html#ad72a0dd5b254704625684cba98acbfd5">More...</a><br /></td></tr>
<tr class="separator:ad72a0dd5b254704625684cba98acbfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58022b8f2c367ce7aadd52ee20ad7095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a58022b8f2c367ce7aadd52ee20ad7095">stack_callback</a> (const geometry_msgs::PoseStampedPtr &amp;msg)</td></tr>
<tr class="memdesc:a58022b8f2c367ce7aadd52ee20ad7095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione callback chiamata dopo la ricezione del messaggio dal nodo del planning, inizializza la posa finale in base ai valori del messaggio. In aggiunta setta la variabile flag 'stack_flag' per segnalare al loop principale di eseguire il movimento.  <a href="motion__planner__node_8cpp.html#a58022b8f2c367ce7aadd52ee20ad7095">More...</a><br /></td></tr>
<tr class="separator:a58022b8f2c367ce7aadd52ee20ad7095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5710f4e95f3dbf7c91d89838745acc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="motion__planner__node_8cpp.html#a5710f4e95f3dbf7c91d89838745acc71">place_callback</a> (const geometry_msgs::PoseStampedPtr &amp;msg)</td></tr>
<tr class="memdesc:a5710f4e95f3dbf7c91d89838745acc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione callback chiamata dopo la ricezione del messaggio dal nodo del planning, inizializza la posa finale in base ai valori del messaggio. In aggiunta setta la variabile flag 'place_flag' per segnalare al loop principale di eseguire il movimento.  <a href="motion__planner__node_8cpp.html#a5710f4e95f3dbf7c91d89838745acc71">More...</a><br /></td></tr>
<tr class="separator:a5710f4e95f3dbf7c91d89838745acc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a29781a20c5dd4153c3c1cecf0ff328"><td class="memItemLeft" align="right" valign="top"><a id="a7a29781a20c5dd4153c3c1cecf0ff328"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>main</b> (int argc, char **args)</td></tr>
<tr class="separator:a7a29781a20c5dd4153c3c1cecf0ff328"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8f87ff30c238757c76dcc8dc3dc0c85b"><td class="memItemLeft" align="right" valign="top"><a id="a8f87ff30c238757c76dcc8dc3dc0c85b"></a>
moveit::planning_interface::MoveGroupInterface *&#160;</td><td class="memItemRight" valign="bottom"><b>arm_group</b></td></tr>
<tr class="separator:a8f87ff30c238757c76dcc8dc3dc0c85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ba50d04a0a6dc69353446908c510e4"><td class="memItemLeft" align="right" valign="top"><a id="a10ba50d04a0a6dc69353446908c510e4"></a>
moveit::planning_interface::MoveGroupInterface::Plan *&#160;</td><td class="memItemRight" valign="bottom"><b>arm_motion_plan</b></td></tr>
<tr class="separator:a10ba50d04a0a6dc69353446908c510e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27762e7dde7d3a157bbe5581d806c66"><td class="memItemLeft" align="right" valign="top"><a id="ab27762e7dde7d3a157bbe5581d806c66"></a>
moveit::planning_interface::MoveGroupInterface *&#160;</td><td class="memItemRight" valign="bottom"><b>gripper_group</b></td></tr>
<tr class="separator:ab27762e7dde7d3a157bbe5581d806c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476d6a68dde4335da6c09d64f46a06fc"><td class="memItemLeft" align="right" valign="top"><a id="a476d6a68dde4335da6c09d64f46a06fc"></a>
moveit::planning_interface::MoveGroupInterface::Plan *&#160;</td><td class="memItemRight" valign="bottom"><b>gripper_motion_plan</b></td></tr>
<tr class="separator:a476d6a68dde4335da6c09d64f46a06fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae497a4c6eb28491cfd532c684efd6b3c"><td class="memItemLeft" align="right" valign="top"><a id="ae497a4c6eb28491cfd532c684efd6b3c"></a>
moveit_msgs::Constraints&#160;</td><td class="memItemRight" valign="bottom"><b>lab_gripper</b></td></tr>
<tr class="separator:ae497a4c6eb28491cfd532c684efd6b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24eadc8a511670e7b52193da87cafd8"><td class="memItemLeft" align="right" valign="top"><a id="ad24eadc8a511670e7b52193da87cafd8"></a>
moveit::planning_interface::PlanningSceneInterface *&#160;</td><td class="memItemRight" valign="bottom"><b>planning_scene_interface</b></td></tr>
<tr class="separator:ad24eadc8a511670e7b52193da87cafd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bec6f19927e1e5fa02b6300f4baca5"><td class="memItemLeft" align="right" valign="top"><a id="ab1bec6f19927e1e5fa02b6300f4baca5"></a>
shape_msgs::SolidPrimitive&#160;</td><td class="memItemRight" valign="bottom"><b>cube_primitive</b></td></tr>
<tr class="separator:ab1bec6f19927e1e5fa02b6300f4baca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c7749d1e5b28472781f3d32ae456f"><td class="memItemLeft" align="right" valign="top"><a id="a447c7749d1e5b28472781f3d32ae456f"></a>
shape_msgs::SolidPrimitive&#160;</td><td class="memItemRight" valign="bottom"><b>parallelepiped_primitive</b></td></tr>
<tr class="separator:a447c7749d1e5b28472781f3d32ae456f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f50881dedd675e08a2ace27c7a584b1"><td class="memItemLeft" align="right" valign="top"><a id="a9f50881dedd675e08a2ace27c7a584b1"></a>
moveit_msgs::AttachedCollisionObject&#160;</td><td class="memItemRight" valign="bottom"><b>block_collision</b></td></tr>
<tr class="separator:a9f50881dedd675e08a2ace27c7a584b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10db94d9432e226e4b297441ac3e030a"><td class="memItemLeft" align="right" valign="top"><a id="a10db94d9432e226e4b297441ac3e030a"></a>
moveit_msgs::AttachedCollisionObject&#160;</td><td class="memItemRight" valign="bottom"><b>detach_object</b></td></tr>
<tr class="separator:a10db94d9432e226e4b297441ac3e030a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44530fd5be28a064fa50e6679c1b1f4"><td class="memItemLeft" align="right" valign="top"><a id="ad44530fd5be28a064fa50e6679c1b1f4"></a>
moveit_msgs::CollisionObject&#160;</td><td class="memItemRight" valign="bottom"><b>remove_object</b></td></tr>
<tr class="separator:ad44530fd5be28a064fa50e6679c1b1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fa81b152e7104ee0eafc0389e0b44c"><td class="memItemLeft" align="right" valign="top"><a id="af6fa81b152e7104ee0eafc0389e0b44c"></a>
moveit::core::RobotStatePtr&#160;</td><td class="memItemRight" valign="bottom"><b>current_state</b></td></tr>
<tr class="separator:af6fa81b152e7104ee0eafc0389e0b44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb080b0aee00f1d669017fb65cf1d23e"><td class="memItemLeft" align="right" valign="top"><a id="adb080b0aee00f1d669017fb65cf1d23e"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>joint_group_positions</b></td></tr>
<tr class="separator:adb080b0aee00f1d669017fb65cf1d23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bdf1df984dca3bd38419948a77ba42"><td class="memItemLeft" align="right" valign="top"><a id="a44bdf1df984dca3bd38419948a77ba42"></a>
const moveit::core::JointModelGroup *&#160;</td><td class="memItemRight" valign="bottom"><b>joint_model_group</b></td></tr>
<tr class="separator:a44bdf1df984dca3bd38419948a77ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46369da9f4cf2d05b9f92ae8fa8ec634"><td class="memItemLeft" align="right" valign="top"><a id="a46369da9f4cf2d05b9f92ae8fa8ec634"></a>
trajectory_processing::TimeOptimalTrajectoryGeneration *&#160;</td><td class="memItemRight" valign="bottom"><b>totg</b></td></tr>
<tr class="separator:a46369da9f4cf2d05b9f92ae8fa8ec634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d091a6138ccf23563bb49693ba09edd"><td class="memItemLeft" align="right" valign="top"><a id="a5d091a6138ccf23563bb49693ba09edd"></a>
robot_trajectory::RobotTrajectory *&#160;</td><td class="memItemRight" valign="bottom"><b>robot_traj</b></td></tr>
<tr class="separator:a5d091a6138ccf23563bb49693ba09edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238082e8d4665aaff69939528db27b3b"><td class="memItemLeft" align="right" valign="top"><a id="a238082e8d4665aaff69939528db27b3b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cube_index</b> = 0</td></tr>
<tr class="separator:a238082e8d4665aaff69939528db27b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849952f2dc11118ded956e6b1514c211"><td class="memItemLeft" align="right" valign="top"><a id="a849952f2dc11118ded956e6b1514c211"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>parallelepiped_index</b> = 0</td></tr>
<tr class="separator:a849952f2dc11118ded956e6b1514c211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00697d7ae787e18f2405deda8e0eb480"><td class="memItemLeft" align="right" valign="top"><a id="a00697d7ae787e18f2405deda8e0eb480"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_counter</b> = 0</td></tr>
<tr class="separator:a00697d7ae787e18f2405deda8e0eb480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3e4076ceacba9a7d0604fee0f8d61"><td class="memItemLeft" align="right" valign="top"><a id="a4bf3e4076ceacba9a7d0604fee0f8d61"></a>
std::array&lt; int,((BUFFER_PARA_ROWS *BUFFER_PARA_PER_ROW)+(BUFFER_CUBE_ROWS *BUFFER_CUBE_PER_ROW))&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_vector</b></td></tr>
<tr class="separator:a4bf3e4076ceacba9a7d0604fee0f8d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae269af16610d7ee6cbb981aab5747313"><td class="memItemLeft" align="right" valign="top"><a id="ae269af16610d7ee6cbb981aab5747313"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cube_local_index</b> = 0</td></tr>
<tr class="separator:ae269af16610d7ee6cbb981aab5747313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723f3bd7a1f2a99741d29383dc18c4ea"><td class="memItemLeft" align="right" valign="top"><a id="a723f3bd7a1f2a99741d29383dc18c4ea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>parallelepiped_local_index</b> = 0</td></tr>
<tr class="separator:a723f3bd7a1f2a99741d29383dc18c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dea4caabbae81fdb7570855449ef802"><td class="memItemLeft" align="right" valign="top"><a id="a9dea4caabbae81fdb7570855449ef802"></a>
ros::ServiceClient&#160;</td><td class="memItemRight" valign="bottom"><b>attach_srv</b></td></tr>
<tr class="separator:a9dea4caabbae81fdb7570855449ef802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2a47ac525ec9f88d2b6b5a3f805c2"><td class="memItemLeft" align="right" valign="top"><a id="abbf2a47ac525ec9f88d2b6b5a3f805c2"></a>
ros::ServiceClient&#160;</td><td class="memItemRight" valign="bottom"><b>detach_srv</b></td></tr>
<tr class="separator:abbf2a47ac525ec9f88d2b6b5a3f805c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bcd065930a8a7f9f194078d9977268"><td class="memItemLeft" align="right" valign="top"><a id="a17bcd065930a8a7f9f194078d9977268"></a>
ros::ServiceClient&#160;</td><td class="memItemRight" valign="bottom"><b>client</b></td></tr>
<tr class="separator:a17bcd065930a8a7f9f194078d9977268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6733c25cfb8525bc250e460d2ca3c18"><td class="memItemLeft" align="right" valign="top"><a id="ad6733c25cfb8525bc250e460d2ca3c18"></a>
ros::ServiceClient&#160;</td><td class="memItemRight" valign="bottom"><b>spawn_model</b></td></tr>
<tr class="separator:ad6733c25cfb8525bc250e460d2ca3c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc56242f4b34b814103415920cd87ca"><td class="memItemLeft" align="right" valign="top"><a id="a6dc56242f4b34b814103415920cd87ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TARGET_BUFFER_FLAG</b> = false</td></tr>
<tr class="separator:a6dc56242f4b34b814103415920cd87ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab116f4e9f37c7dc32f3bf8efb5a40ffc"><td class="memItemLeft" align="right" valign="top"><a id="ab116f4e9f37c7dc32f3bf8efb5a40ffc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TARGET_CASTLE_FLAG</b> = false</td></tr>
<tr class="separator:ab116f4e9f37c7dc32f3bf8efb5a40ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5053965333118b1dcbf130f7ff6e8669"><td class="memItemLeft" align="right" valign="top"><a id="a5053965333118b1dcbf130f7ff6e8669"></a>
pcl_action::custom&#160;</td><td class="memItemRight" valign="bottom"><b>pos_msg</b></td></tr>
<tr class="separator:a5053965333118b1dcbf130f7ff6e8669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e2966f2c04dcc44270397716f45938"><td class="memItemLeft" align="right" valign="top"><a id="a56e2966f2c04dcc44270397716f45938"></a>
geometry_msgs::PoseStamped&#160;</td><td class="memItemRight" valign="bottom"><b>action_msg</b></td></tr>
<tr class="separator:a56e2966f2c04dcc44270397716f45938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af6cc43a175d2f71becf931d329b5f9"><td class="memItemLeft" align="right" valign="top"><a id="a1af6cc43a175d2f71becf931d329b5f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>iscube</b> = false</td></tr>
<tr class="separator:a1af6cc43a175d2f71becf931d329b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d57dd8066ff0f041190bc0d85591034"><td class="memItemLeft" align="right" valign="top"><a id="a7d57dd8066ff0f041190bc0d85591034"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>position_flag</b> = false</td></tr>
<tr class="separator:a7d57dd8066ff0f041190bc0d85591034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0d13941d8ded70290b040f365fac49"><td class="memItemLeft" align="right" valign="top"><a id="a9b0d13941d8ded70290b040f365fac49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pickup_flag</b> = false</td></tr>
<tr class="separator:a9b0d13941d8ded70290b040f365fac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e95c9d4dbbcf7594d773caea234aa2a"><td class="memItemLeft" align="right" valign="top"><a id="a9e95c9d4dbbcf7594d773caea234aa2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stack_flag</b> = false</td></tr>
<tr class="separator:a9e95c9d4dbbcf7594d773caea234aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af29b85fe4abc417a88dc470ae57558"><td class="memItemLeft" align="right" valign="top"><a id="a4af29b85fe4abc417a88dc470ae57558"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>place_flag</b> = false</td></tr>
<tr class="separator:a4af29b85fe4abc417a88dc470ae57558"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ROS Node che esegue il movimento completo del braccio completo leggendo i valori dai messaggi dei topic specifici. </p>
<dl class="section author"><dt>Author</dt><dd>Davide Trevisi </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022-07-17</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2022 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4ab62f81b3f3a3625b4f73c19ceeff62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab62f81b3f3a3625b4f73c19ceeff62">&#9670;&nbsp;</a></span>add_cube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_cube </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che aggiunge il cubo specificato a Gazebo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>posa (X, Y, Z, x, y, z, w) dell'oggetto da aggiungere </td></tr>
    <tr><td class="paramname">index</td><td>indice dell'oggetto da aggiungere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19e2f3befdda031eac3f973b147f6567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e2f3befdda031eac3f973b147f6567">&#9670;&nbsp;</a></span>add_cube_collision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_cube_collision </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che aggiunge l'oggetto di collisione 'cube_collision_ <em>index</em> ' alla scena MoveIt! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>posa (X, Y, Z, x, y, z, w) dell'oggetto da aggiungere alle collisioni </td></tr>
    <tr><td class="paramname">index</td><td>indice dell'oggetto da aggiungere alle collisioni </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a4cdd7ecb35c7c3a09042860e634b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4cdd7ecb35c7c3a09042860e634b71">&#9670;&nbsp;</a></span>add_parallelepiped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_parallelepiped </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che aggiunge il parallelepipedo specificato a Gazebo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>posa (X, Y, Z, x, y, z, w) dell'oggetto da aggiungere </td></tr>
    <tr><td class="paramname">index</td><td>indice dell'oggetto da aggiungere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1c8604f264a12ae8c9eddafa32234f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c8604f264a12ae8c9eddafa32234f0">&#9670;&nbsp;</a></span>add_parallelepiped_collision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_parallelepiped_collision </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che aggiunge l'oggetto di collisione 'parallelepiped_collision_ <em>index</em> ' alla scena MoveIt! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>posa (X, Y, Z, x, y, z, w) dell'oggetto da aggiungere alle collisioni </td></tr>
    <tr><td class="paramname">index</td><td>indice dell'oggetto da aggiungere alle collisioni </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a859cd1bdea5bd730a7534e3a5c8cdbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859cd1bdea5bd730a7534e3a5c8cdbbc">&#9670;&nbsp;</a></span>buffer_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_callback </td>
          <td>(</td>
          <td class="paramtype">const pcl_action::custom::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione callback chiamata dopo la ricezione del messaggio dal nodo della camera, inizializza la posa iniziale e il tipo di blocco in base ai valori del messaggio. In aggiunta setta la variabile flag 'position_flag' per segnalare al loop principale di eseguire il movimento. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>messaggio proveniente dal nodo 'pcl_action' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3536311b9a73eafe4618611c0362d9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3536311b9a73eafe4618611c0362d9a7">&#9670;&nbsp;</a></span>close_gripper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_gripper </td>
          <td>(</td>
          <td class="paramtype">ros::Publisher&#160;</td>
          <td class="paramname"><em>pub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue la chiusura del gripper in ambiente reale e simulato. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pub</td><td>publisher ROS utlilzzato per l'invio di messaggi nel topic 'gripper_controller_cmd'. Usato solo in ambiente reale </td></tr>
    <tr><td class="paramname">model</td><td>nome del modello di Gazebo da prendere dopo l'apertura ( <em>cube-parallelepiped</em> , usato soltanto in Gazebo) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f686a6191d7d83185c21872036fb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f686a6191d7d83185c21872036fb79">&#9670;&nbsp;</a></span>confirmation_msgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void confirmation_msgs </td>
          <td>(</td>
          <td class="paramtype">ros::Publisher&#160;</td>
          <td class="paramname"><em>confirmation_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che invia il messaggio di conferma del movimento al nodo del planning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">confirmation_pub</td><td>publisher ROS utlilzzato per l'invio di messaggi nel topic 'confirmation_topic' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3e12409508f78abe16f1741c18637fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e12409508f78abe16f1741c18637fc">&#9670;&nbsp;</a></span>execute_Cartesian_Path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void execute_Cartesian_Path </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue il planning ed il movimento del braccio linearmente verso una posa dell'end-effector passata come parametro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>posa (X, Y, Z, x, y, z, w) che dovrà avere l'end-effector del braccio al termine del movimento </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77c918a2f229ff3dd525a627351c35b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c918a2f229ff3dd525a627351c35b4">&#9670;&nbsp;</a></span>get_buffer_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Pose get_buffer_target </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>counter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che calcola la posa dell'end-effector per posizionare il blocco nel buffer tramite l'indice 'counter'. La funzione calcola la posa in base alle costanti presenti e alle pose di default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>variabile che tiene conto del numero dei blocchi inseriti (0, n-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>posa target dell'end-effector per il posizionamento del blocco nel buffer, nulla in caso di buffer pieno </dd></dl>

</div>
</div>
<a id="ad8b92b4fd213b7801012434961330419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b92b4fd213b7801012434961330419">&#9670;&nbsp;</a></span>get_index_from_buffer_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_index_from_buffer_pose </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che trova l'indice tra le collisioni del blocco con la posa specificata e lo ritorna. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>posa (X, Y, Z, x, y, z, w) dell'oggetto da trovare nelle collisioni</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int contenente l'indice della collision, -1 in caso di errore </dd></dl>

</div>
</div>
<a id="a2f4f7edb241686aacb8145a9ba417e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4f7edb241686aacb8145a9ba417e2d">&#9670;&nbsp;</a></span>motion_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void motion_plan </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue il planning ed il movimento del braccio verso una posa dell'end-effector passata come parametro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>posa (X, Y, Z, x, y, z, w) che dovrà avere l'end-effector del braccio al termine del movimento </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad6bf04107d106688d681b97a334801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad6bf04107d106688d681b97a334801">&#9670;&nbsp;</a></span>motion_plan_middle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void motion_plan_middle </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue il planning ed il movimento del braccio verso una posa dell'end-effector data come parametro, passando per un punto intermedio definito a priori come posa (nel file .srdf di MoveIt!). Il movimento è l'unione di due traiettorie pianificate separatamente e con il timing ricalcolato. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>posa (X, Y, Z, x, y, z, w) che dovrà avere l'end-effector del braccio al termine del movimento </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaa2b60e07dd3330105db81b4db9b2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa2b60e07dd3330105db81b4db9b2b3">&#9670;&nbsp;</a></span>open_gripper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open_gripper </td>
          <td>(</td>
          <td class="paramtype">ros::Publisher&#160;</td>
          <td class="paramname"><em>pub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue l'apertura del gripper in ambiente reale e simulato. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pub</td><td>publisher ROS utlilzzato per l'invio di messaggi nel topic 'gripper_controller_cmd'. Usato solo in ambiente reale </td></tr>
    <tr><td class="paramname">model</td><td>nome del modello di Gazebo da rilasciare dopo l'apertura ( <em>cube-parallelepiped</em> , usato soltanto in Gazebo) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af608bba0b50bde82e9edd251fda75662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af608bba0b50bde82e9edd251fda75662">&#9670;&nbsp;</a></span>pickup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pickup </td>
          <td>(</td>
          <td class="paramtype">ros::Publisher&#160;</td>
          <td class="paramname"><em>gripper_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue il movimento in sequenza del braccio, chiamando le apposite funzioni, per la presa dei blocchi (con collisioni) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gripper_pub</td><td>publisher ROS utlilzzato per l'invio di messaggi nel topic 'gripper_controller_cmd'. Usato solo in ambiente reale </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad72a0dd5b254704625684cba98acbfd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72a0dd5b254704625684cba98acbfd5">&#9670;&nbsp;</a></span>pickup_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pickup_callback </td>
          <td>(</td>
          <td class="paramtype">const geometry_msgs::PoseStampedPtr &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione callback chiamata dopo la ricezione del messaggio dal nodo del planning, inizializza la posa finale in base ai valori del messaggio. In aggiunta setta la variabile flag 'pickup_flag' per segnalare al loop principale di eseguire il movimento. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>messaggio proveniente dal nodo 'action_controller_node' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fb468c8404de768b7718baf3afffe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb468c8404de768b7718baf3afffe7c">&#9670;&nbsp;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void place </td>
          <td>(</td>
          <td class="paramtype">ros::Publisher&#160;</td>
          <td class="paramname"><em>gripper_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue il movimento in sequenza del braccio, chiamando le apposite funzioni, per il posizionamento dei blocchi (con collisioni) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gripper_pub</td><td>publisher ROS utlilzzato per l'invio di messaggi nel topic 'gripper_controller_cmd'. Usato solo in ambiente reale </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5710f4e95f3dbf7c91d89838745acc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5710f4e95f3dbf7c91d89838745acc71">&#9670;&nbsp;</a></span>place_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void place_callback </td>
          <td>(</td>
          <td class="paramtype">const geometry_msgs::PoseStampedPtr &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione callback chiamata dopo la ricezione del messaggio dal nodo del planning, inizializza la posa finale in base ai valori del messaggio. In aggiunta setta la variabile flag 'place_flag' per segnalare al loop principale di eseguire il movimento. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>messaggio proveniente dal nodo 'action_controller_node' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3b2ee5dbf47d7ba57716e68e1c3eb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b2ee5dbf47d7ba57716e68e1c3eb28">&#9670;&nbsp;</a></span>removeCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeCollision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che rimuove le collisioni dalla scena MoveIt! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>numero del segnale </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad20897c5c8bd47f5d4005989bead0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20897c5c8bd47f5d4005989bead0e55">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che esegue il movimento in sequenza del braccio, chiamando le apposite funzioni, per il posizionamento di default del manipolatore. </p>

</div>
</div>
<a id="a0c40266d9f81945e7305b9f706067772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c40266d9f81945e7305b9f706067772">&#9670;&nbsp;</a></span>robot_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void robot_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che inizializza le costrizioni dei vari valori dei joint e orientazione dell'end-effector del braccio, valori testati in modo da limitare il braccio all'area di lavoro per favorire soluzioni 'ottimali' dell'inverse kinematics. </p>

</div>
</div>
<a id="a792e44f027d5c332de077c7d367714ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792e44f027d5c332de077c7d367714ef">&#9670;&nbsp;</a></span>rotate_end_effector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotate_end_effector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joint_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che assegna ad un determinato joint un valore passato come parametro (consultare il file URDF del robot per maggiori informazioni, numerazione crescente) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_number</td><td>il numero del joint del robot su cui agire </td></tr>
    <tr><td class="paramname">amount</td><td>angolo che avrà <em>joint_number</em> dopo il movimento </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d6c18e17b9d822531a159010049d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6c18e17b9d822531a159010049d175">&#9670;&nbsp;</a></span>select_arm_motion_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_arm_motion_plan </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che sceglie se far passare il braccio per il punto medio oppure no. Il passaggio avviene supponendo di divirere il tavolo di lavoro in due metà rispetto all'origine del robot: se origine e destinazione si trovano sulla stessa metà allora non serve passare per il waypoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>posa (X, Y, Z, x, y, z, w) che dovrà avere l'end-effector del braccio al termine del movimento </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fc01d736fe50cf5b977f755b675f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc01d736fe50cf5b977f755b675f11d">&#9670;&nbsp;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzone che inizializza le variabili globali e i puntatori. </p>

</div>
</div>
<a id="a58022b8f2c367ce7aadd52ee20ad7095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58022b8f2c367ce7aadd52ee20ad7095">&#9670;&nbsp;</a></span>stack_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stack_callback </td>
          <td>(</td>
          <td class="paramtype">const geometry_msgs::PoseStampedPtr &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione callback chiamata dopo la ricezione del messaggio dal nodo del planning, inizializza la posa finale in base ai valori del messaggio. In aggiunta setta la variabile flag 'stack_flag' per segnalare al loop principale di eseguire il movimento. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>messaggio proveniente dal nodo 'action_controller_node' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
